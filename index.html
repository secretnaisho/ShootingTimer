<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clap Reaction Trainer</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 24px; background:#fff; }
    .card { max-width: 560px; margin: 0 auto; }
    button { font-size: 18px; padding: 12px 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .big { font-size: 44px; font-weight: 700; margin: 16px 0; }
    .status { padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; }
    input[type="range"]{ width: 240px; }
    .muted { color:#666; font-size: 13px; }

    /* 演出用レイヤー（操作は可能なままにしておく） */
    .overlay {
      position: fixed; inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 80ms linear;
      z-index: 9999;
    }
    .overlay.on { opacity: 1; }

    /* 黒画面（ブラックアウト） */
    #blackout { background: #000; }

    /* 白画面（GO/結果表示用） */
    #whiteout { background: #fff; }

    /* ボタン補助（Resetを目立たせ過ぎない） */
    #resetBtn { opacity: 0.9; }
  </style>
</head>
<body>
  <!-- 演出用レイヤー -->
  <div class="overlay" id="blackout"></div>
  <div class="overlay" id="whiteout"></div>

  <div class="card">
    <h1>Clap Reaction Trainer</h1>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="resetBtn">Reset</button>
    </div>

    <p class="status" id="status">Ready.</p>
    <div class="big" id="time">--.--</div>

    <div class="row">
      <label>Clap sensitivity</label>
      <input id="threshold" type="range" min="0.02" max="0.30" step="0.01" value="0.10">
      <span id="thrVal">0.10</span>
    </div>
    <p class="muted">
      iPhoneは最初に「Start」を押してマイク許可が必要です。反応が早すぎる/遅すぎる時は感度を調整。
      「Stop」は中断、「Reset」は完全初期化（白/黒画面からも復帰）です。
    </p>
  </div>

<script>
(() => {
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const resetBtn = document.getElementById("resetBtn");

  const statusEl = document.getElementById("status");
  const timeEl   = document.getElementById("time");
  const thr      = document.getElementById("threshold");
  const thrVal   = document.getElementById("thrVal");

  const blackoutEl = document.getElementById("blackout");
  const whiteoutEl = document.getElementById("whiteout");

  thr.addEventListener("input", () => thrVal.textContent = Number(thr.value).toFixed(2));

  let audioCtx, analyser, data;
  let listening = false;     // 監視ループが動いているか
  let armed = false;         // GO後（計測中）か
  let startedAt = 0;         // GOの瞬間
  let rafId = 0;             // requestAnimationFrameのID
  let preTimer = 0;          // setTimeoutのID（演出＆ランダム待機）
  let lockoutUntil = 0;      // 合図直後の誤検知防止
  let hasRunOnce = false;    // 2回目以降Start表記をRestartにする

  // 「Start押した後の演出」を途中キャンセルできるようにする
  let seqToken = 0;

  function now() { return performance.now(); }
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function setBlackout(on) { blackoutEl.classList.toggle("on", !!on); }
  function setWhiteout(on) { whiteoutEl.classList.toggle("on", !!on); }

  function stopAllTimers() {
    cancelAnimationFrame(rafId);
    clearTimeout(preTimer);
    rafId = 0;
    preTimer = 0;
  }

  function beep() {
    // 小さなビープ音（任意）。iOSはユーザー操作後なら鳴ります
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine";
    o.frequency.value = 880;
    g.gain.value = 0.05;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.08);
  }

  async function initAudio() {
    if (audioCtx) return;

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    data = new Uint8Array(analyser.fftSize);
    src.connect(analyser);
  }

  function rmsFromTimeDomain() {
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      const v = (data[i] - 128) / 128; // -1..1
      sum += v * v;
    }
    return Math.sqrt(sum / data.length);
  }

  function loop() {
    if (!listening) return;

    const level = rmsFromTimeDomain();
    const threshold = Number(thr.value);

    // GO後のみ検知（合図直後のロックアウトも考慮）
    if (armed && now() > lockoutUntil && level > threshold) {
      stopWithTime(now() - startedAt);
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function resetUI(msg="Ready.") {
    statusEl.textContent = msg;
    timeEl.textContent = "--.--";
    setBlackout(false);
    setWhiteout(false);

    // 表記（初回はStart、2回目以降はRestart）
    startBtn.textContent = hasRunOnce ? "Restart" : "Start";
  }

  function hardStop(msg="Stopped.") {
    // 演出の途中キャンセル用トークンを進める
    seqToken++;

    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    // 白/黒から必ず復帰
    setBlackout(false);
    setWhiteout(false);

    resetUI(msg);
  }

  function hardReset(msg="Reset.") {
    // Resetは「完全初期化」扱いにする（表記もStartへ戻す）
    hasRunOnce = false;
    seqToken++;
    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    setBlackout(false);
    setWhiteout(false);

    statusEl.textContent = msg;
    timeEl.textContent = "--.--";
    startBtn.textContent = "Start";
  }

  function stopWithTime(ms) {
    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    const sec = ms / 1000;
    timeEl.textContent = sec.toFixed(2);
    statusEl.textContent = `Time: ${sec.toFixed(2)}s`;

    // 終了後は白画面で結果を見せる
    setBlackout(false);
    setWhiteout(true);

    // 2回目以降はRestart表記
    hasRunOnce = true;
    startBtn.textContent = "Restart";
  }

  async function runStartSequence(myToken) {
    // 1) Shooter On The Line（3秒）
    statusEl.textContent = "Shooter On The Line";
    await sleep(3000);
    if (myToken !== seqToken) return;

    // 2) Shooter Set（3秒）
    statusEl.textContent = "Shooter Set";
    await sleep(3000);
    if (myToken !== seqToken) return;

    // 3) ブラックアウト
    setWhiteout(false);
    setBlackout(true);
    statusEl.textContent = "Stand by...";
    if (myToken !== seqToken) return;

    // 4) 1〜5秒ランダム待機
    const minMs = 1000;
    const maxMs = 5000;
    const delay = Math.random() * (maxMs - minMs) + minMs;

    preTimer = setTimeout(() => {
      if (myToken !== seqToken) return;

      // 5) 白画面＝GO → 計測開始
      setBlackout(false);
      setWhiteout(true);
      beep();

      startedAt = now();
      lockoutUntil = startedAt + 120; // 合図直後の誤検知対策
      armed = true;

      statusEl.textContent = "GO!";
    }, delay);
  }

  startBtn.addEventListener("click", async () => {
    try {
      // 連打対策（演出/計測中はStart無効）
      startBtn.disabled = true;
      stopBtn.disabled = false;

      statusEl.textContent = "Requesting microphone permission...";
      await initAudio();

      // iOS対策：AudioContextがsuspendedならresume
      if (audioCtx.state === "suspended") await audioCtx.resume();

      // 計測準備
      listening = true;
      armed = false;

      // 念のため停止系をクリアしてから開始
      stopAllTimers();

      // 監視ループ開始
      rafId = requestAnimationFrame(loop);

      // シーケンス開始（表示→ブラックアウト→ランダム→GO）
      const myToken = ++seqToken; // この開始シーケンスのID
      await runStartSequence(myToken);

    } catch (e) {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      resetUI("Microphone error. Browser permission or unsupported device.");
      console.error(e);
    }
  });

  stopBtn.addEventListener("click", () => {
    hardStop("Stopped.");
  });

  resetBtn.addEventListener("click", () => {
    hardReset("Reset.");
  });

  // 初期表示
  resetUI("Ready.");
})();
</script>
</body>
</html>
