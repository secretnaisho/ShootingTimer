<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clap Reaction Trainer</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 24px; background:#fff; }
    .card { max-width: 560px; margin: 0 auto; }
    button { font-size: 18px; padding: 12px 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .big { font-size: 44px; font-weight: 700; margin: 16px 0; }
    .status { padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; }
    input[type="range"]{ width: 240px; }
    .muted { color:#666; font-size: 13px; }

    /* ç”»é¢æ¼”å‡ºãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆæ“ä½œã¯ç„¡åŠ¹åŒ–ã›ãšã€è¡¨ç¤ºã ã‘å¤‰ãˆã‚‹ï¼‰ */
    .overlay {
      position: fixed; inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 80ms linear;
      z-index: 9999;
    }
    .overlay.on { opacity: 1; }

    /* é»’ç”»é¢ï¼ˆãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆï¼‰ */
    #blackout { background: #000; }

    /* ç™½ç”»é¢ï¼ˆGO/çµæœè¡¨ç¤ºç”¨ï¼‰ */
    #whiteout { background: #fff; }
  </style>
</head>
<body>
  <!-- æ¼”å‡ºç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
  <div class="overlay" id="blackout"></div>
  <div class="overlay" id="whiteout"></div>

  <div class="card">
    <h1>ğŸ”« ç°¡æ˜“å‹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒ‰ãƒ­ãƒ¼ã‚¿ã‚¤ãƒãƒ¼</h1>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <p class="status" id="status">Ready.</p>
    <div class="big" id="time">--.--</div>

    <div class="row">
      <label>Clap sensitivity</label>
      <input id="threshold" type="range" min="0.02" max="0.30" step="0.01" value="0.10">
      <span id="thrVal">0.10</span>
    </div>
    <p class="muted">
      iPhoneã¯æœ€åˆã«ã€ŒStartã€ã‚’æŠ¼ã—ã¦ãƒã‚¤ã‚¯è¨±å¯ãŒå¿…è¦ã§ã™ã€‚åå¿œãŒæ—©ã™ãã‚‹/é…ã™ãã‚‹æ™‚ã¯æ„Ÿåº¦ã‚’èª¿æ•´ã€‚
    </p>
  </div>

<script>
(() => {
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const statusEl = document.getElementById("status");
  const timeEl   = document.getElementById("time");
  const thr      = document.getElementById("threshold");
  const thrVal   = document.getElementById("thrVal");

  const blackoutEl = document.getElementById("blackout");
  const whiteoutEl = document.getElementById("whiteout");

  thr.addEventListener("input", () => thrVal.textContent = Number(thr.value).toFixed(2));

  let audioCtx, analyser, data;
  let listening = false;
  let armed = false;
  let startedAt = 0;
  let rafId = 0;
  let preTimer = 0;
  let lockoutUntil = 0;

  // 2å›ç›®ä»¥é™ã®è¡¨è¨˜ã‚’Restartã«ã™ã‚‹ãŸã‚
  let hasRunOnce = false;

  function now() { return performance.now(); }
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function setBlackout(on) {
    blackoutEl.classList.toggle("on", !!on);
  }
  function setWhiteout(on) {
    whiteoutEl.classList.toggle("on", !!on);
  }

  function beep() {
    // å°ã•ãªãƒ“ãƒ¼ãƒ—éŸ³ï¼ˆä»»æ„ï¼‰ã€‚iOSã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œãªã‚‰é³´ã‚Šã¾ã™
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine";
    o.frequency.value = 880;
    g.gain.value = 0.05;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.08);
  }

  async function initAudio() {
    if (audioCtx) return;

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    data = new Uint8Array(analyser.fftSize);
    src.connect(analyser);
  }

  function rmsFromTimeDomain() {
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      const v = (data[i] - 128) / 128; // -1..1
      sum += v * v;
    }
    return Math.sqrt(sum / data.length);
  }

  function loop() {
    if (!listening) return;

    const level = rmsFromTimeDomain();
    const threshold = Number(thr.value);

    // GOå¾Œã®ã¿æ¤œçŸ¥ï¼ˆåˆå›³ç›´å¾Œã®ãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã‚‚è€ƒæ…®ï¼‰
    if (armed && now() > lockoutUntil && level > threshold) {
      stopWithTime(now() - startedAt);
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function stopAllTimers() {
    cancelAnimationFrame(rafId);
    clearTimeout(preTimer);
    rafId = 0;
    preTimer = 0;
  }

  function stopWithTime(ms) {
    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    const sec = ms / 1000;
    timeEl.textContent = sec.toFixed(2);
    statusEl.textContent = `Time: ${sec.toFixed(2)}s`;

    // çµ‚äº†å¾Œã¯ç™½ç”»é¢ã§çµæœã‚’è¦‹ã›ã‚‹
    setBlackout(false);
    setWhiteout(true);

    // 2å›ç›®ä»¥é™ã¯Restartè¡¨è¨˜
    hasRunOnce = true;
    startBtn.textContent = "Restart";
  }

  function resetUI(msg="Ready.") {
    statusEl.textContent = msg;
    timeEl.textContent = "--.--";

    // é€šå¸¸æ™‚ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤OFF
    setBlackout(false);
    setWhiteout(false);

    // è¡¨è¨˜ï¼ˆåˆå›ã¯Startã€2å›ç›®ä»¥é™ã¯Restartï¼‰
    startBtn.textContent = hasRunOnce ? "Restart" : "Start";
  }

  async function runStartSequence() {
    // 1) Shooter On The Lineï¼ˆ3ç§’ï¼‰
    statusEl.textContent = "Shooter On The Line";
    await sleep(3000);

    // 2) Shooter Setï¼ˆ3ç§’ï¼‰
    statusEl.textContent = "Shooter Set";
    await sleep(3000);

    // 3) ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
    setWhiteout(false);
    setBlackout(true);
    statusEl.textContent = "Stand by...";

    // 4) 1ã€œ5ç§’ãƒ©ãƒ³ãƒ€ãƒ å¾…æ©Ÿ
    const minMs = 1000;
    const maxMs = 5000;
    const delay = Math.random() * (maxMs - minMs) + minMs;

    // ç›£è¦–ãƒ«ãƒ¼ãƒ—ã¯å›ã™ãŒã€armed=falseãªã®ã§èª¤æ¤œçŸ¥ã—ãªã„
    preTimer = setTimeout(() => {
      // 5) ç™½ç”»é¢ï¼GO â†’ è¨ˆæ¸¬é–‹å§‹
      setBlackout(false);
      setWhiteout(true);
      beep();

      startedAt = now();
      lockoutUntil = startedAt + 120; // åˆå›³ç›´å¾Œã®èª¤æ¤œçŸ¥å¯¾ç­–
      armed = true;

      statusEl.textContent = "GO!";
    }, delay);
  }

  startBtn.addEventListener("click", async () => {
    try {
      resetUI("Requesting microphone permission...");
      await initAudio();

      // iOSå¯¾ç­–ï¼šAudioContextãŒsuspendedãªã‚‰resume
      if (audioCtx.state === "suspended") await audioCtx.resume();

      // é€£æ‰“å¯¾ç­–
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // è¨ˆæ¸¬æº–å‚™
      listening = true;
      armed = false;
      stopAllTimers();

      // ç›£è¦–ãƒ«ãƒ¼ãƒ—é–‹å§‹
      rafId = requestAnimationFrame(loop);

      // ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹ï¼ˆè¡¨ç¤ºâ†’ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆâ†’ãƒ©ãƒ³ãƒ€ãƒ â†’GOï¼‰
      await runStartSequence();

    } catch (e) {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      resetUI("Microphone error. Browser permission or unsupported device.");
      console.error(e);
    }
  });

  stopBtn.addEventListener("click", () => {
    armed = false;
    listening = false;
    stopAllTimers();
    stopBtn.disabled = true;
    startBtn.disabled = false;
    resetUI("Stopped.");
  });

  // åˆæœŸè¡¨ç¤º
  resetUI("Ready.");
})();
</script>
</body>
</html>

