<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ”«ç°¡æ˜“å‹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆãƒ‰ãƒ­ãƒ¼ã‚¿ã‚¤ãƒãƒ¼</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 24px; background:#fff; }
    .card { max-width: 560px; margin: 0 auto; }
    button { font-size: 18px; padding: 12px 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .big { font-size: 44px; font-weight: 700; margin: 16px 0; }
    .status { padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; }
    input[type="range"]{ width: 240px; }
    .muted { color:#666; font-size: 13px; }

    /* æ¼”å‡ºç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆæ“ä½œã¯å¯èƒ½ãªã¾ã¾ã«ã—ã¦ãŠãï¼‰ */
    .overlay {
      position: fixed; inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 80ms linear;
      z-index: 9999;
    }
    .overlay.on { opacity: 1; }

    /* é»’ç”»é¢ï¼ˆãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆï¼‰ */
    #blackout { background: #000; }

    /* ç™½ç”»é¢ï¼ˆGO/çµæœè¡¨ç¤ºç”¨ï¼‰ */
    #whiteout { background: #fff; }

    /* ãƒœã‚¿ãƒ³è£œåŠ©ï¼ˆResetã‚’ç›®ç«‹ãŸã›éããªã„ï¼‰ */
    #resetBtn { opacity: 0.9; }
  </style>
</head>
<body>
  <!-- æ¼”å‡ºç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
  <div class="overlay" id="blackout"></div>
  <div class="overlay" id="whiteout"></div>

  <div class="card">
    <h1>Clap Reaction Trainer</h1>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="resetBtn">Reset</button>
    </div>

    <p class="status" id="status">Ready.</p>
    <div class="big" id="time">--.--</div>

    <div class="row">
      <label>Clap sensitivity</label>
      <input id="threshold" type="range" min="0.02" max="0.30" step="0.01" value="0.10">
      <span id="thrVal">0.10</span>
    </div>
    <p class="muted">
      iPhoneã¯æœ€åˆã«ã€ŒStartã€ã‚’æŠ¼ã—ã¦ãƒã‚¤ã‚¯è¨±å¯ãŒå¿…è¦ã§ã™ã€‚åå¿œãŒæ—©ã™ãã‚‹/é…ã™ãã‚‹æ™‚ã¯æ„Ÿåº¦ã‚’èª¿æ•´ã€‚
      ã€ŒStopã€ã¯ä¸­æ–­ã€ã€ŒResetã€ã¯å®Œå…¨åˆæœŸåŒ–ï¼ˆç™½/é»’ç”»é¢ã‹ã‚‰ã‚‚å¾©å¸°ï¼‰ã§ã™ã€‚
    </p>
  </div>

<script>
(() => {
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const resetBtn = document.getElementById("resetBtn");

  const statusEl = document.getElementById("status");
  const timeEl   = document.getElementById("time");
  const thr      = document.getElementById("threshold");
  const thrVal   = document.getElementById("thrVal");

  const blackoutEl = document.getElementById("blackout");
  const whiteoutEl = document.getElementById("whiteout");

  thr.addEventListener("input", () => thrVal.textContent = Number(thr.value).toFixed(2));

  let audioCtx, analyser, data;
  let listening = false;     // ç›£è¦–ãƒ«ãƒ¼ãƒ—ãŒå‹•ã„ã¦ã„ã‚‹ã‹
  let armed = false;         // GOå¾Œï¼ˆè¨ˆæ¸¬ä¸­ï¼‰ã‹
  let startedAt = 0;         // GOã®ç¬é–“
  let rafId = 0;             // requestAnimationFrameã®ID
  let preTimer = 0;          // setTimeoutã®IDï¼ˆæ¼”å‡ºï¼†ãƒ©ãƒ³ãƒ€ãƒ å¾…æ©Ÿï¼‰
  let lockoutUntil = 0;      // åˆå›³ç›´å¾Œã®èª¤æ¤œçŸ¥é˜²æ­¢
  let hasRunOnce = false;    // 2å›ç›®ä»¥é™Startè¡¨è¨˜ã‚’Restartã«ã™ã‚‹

  // ã€ŒStartæŠ¼ã—ãŸå¾Œã®æ¼”å‡ºã€ã‚’é€”ä¸­ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
  let seqToken = 0;

  function now() { return performance.now(); }
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function setBlackout(on) { blackoutEl.classList.toggle("on", !!on); }
  function setWhiteout(on) { whiteoutEl.classList.toggle("on", !!on); }

  function stopAllTimers() {
    cancelAnimationFrame(rafId);
    clearTimeout(preTimer);
    rafId = 0;
    preTimer = 0;
  }

  function beep() {
    // å°ã•ãªãƒ“ãƒ¼ãƒ—éŸ³ï¼ˆä»»æ„ï¼‰ã€‚iOSã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œãªã‚‰é³´ã‚Šã¾ã™
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine";
    o.frequency.value = 880;
    g.gain.value = 0.05;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.08);
  }

  async function initAudio() {
    if (audioCtx) return;

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    data = new Uint8Array(analyser.fftSize);
    src.connect(analyser);
  }

  function rmsFromTimeDomain() {
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      const v = (data[i] - 128) / 128; // -1..1
      sum += v * v;
    }
    return Math.sqrt(sum / data.length);
  }

  function loop() {
    if (!listening) return;

    const level = rmsFromTimeDomain();
    const threshold = Number(thr.value);

    // GOå¾Œã®ã¿æ¤œçŸ¥ï¼ˆåˆå›³ç›´å¾Œã®ãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã‚‚è€ƒæ…®ï¼‰
    if (armed && now() > lockoutUntil && level > threshold) {
      stopWithTime(now() - startedAt);
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function resetUI(msg="Ready.") {
    statusEl.textContent = msg;
    timeEl.textContent = "--.--";
    setBlackout(false);
    setWhiteout(false);

    // è¡¨è¨˜ï¼ˆåˆå›ã¯Startã€2å›ç›®ä»¥é™ã¯Restartï¼‰
    startBtn.textContent = hasRunOnce ? "Restart" : "Start";
  }

  function hardStop(msg="Stopped.") {
    // æ¼”å‡ºã®é€”ä¸­ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç”¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€²ã‚ã‚‹
    seqToken++;

    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    // ç™½/é»’ã‹ã‚‰å¿…ãšå¾©å¸°
    setBlackout(false);
    setWhiteout(false);

    resetUI(msg);
  }

  function hardReset(msg="Reset.") {
    // Resetã¯ã€Œå®Œå…¨åˆæœŸåŒ–ã€æ‰±ã„ã«ã™ã‚‹ï¼ˆè¡¨è¨˜ã‚‚Startã¸æˆ»ã™ï¼‰
    hasRunOnce = false;
    seqToken++;
    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    setBlackout(false);
    setWhiteout(false);

    statusEl.textContent = msg;
    timeEl.textContent = "--.--";
    startBtn.textContent = "Start";
  }

  function stopWithTime(ms) {
    armed = false;
    listening = false;
    stopAllTimers();

    stopBtn.disabled = true;
    startBtn.disabled = false;

    const sec = ms / 1000;
    timeEl.textContent = sec.toFixed(2);
    statusEl.textContent = `Time: ${sec.toFixed(2)}s`;

    // çµ‚äº†å¾Œã¯ç™½ç”»é¢ã§çµæœã‚’è¦‹ã›ã‚‹
    setBlackout(false);
    setWhiteout(true);

    // 2å›ç›®ä»¥é™ã¯Restartè¡¨è¨˜
    hasRunOnce = true;
    startBtn.textContent = "Restart";
  }

  async function runStartSequence(myToken) {
    // 1) Shooter On The Lineï¼ˆ3ç§’ï¼‰
    statusEl.textContent = "Shooter On The Line";
    await sleep(3000);
    if (myToken !== seqToken) return;

    // 2) Shooter Setï¼ˆ3ç§’ï¼‰
    statusEl.textContent = "Shooter Set";
    await sleep(3000);
    if (myToken !== seqToken) return;

    // 3) ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
    setWhiteout(false);
    setBlackout(true);
    statusEl.textContent = "Stand by...";
    if (myToken !== seqToken) return;

    // 4) 1ã€œ5ç§’ãƒ©ãƒ³ãƒ€ãƒ å¾…æ©Ÿ
    const minMs = 1000;
    const maxMs = 5000;
    const delay = Math.random() * (maxMs - minMs) + minMs;

    preTimer = setTimeout(() => {
      if (myToken !== seqToken) return;

      // 5) ç™½ç”»é¢ï¼GO â†’ è¨ˆæ¸¬é–‹å§‹
      setBlackout(false);
      setWhiteout(true);
      beep();

      startedAt = now();
      lockoutUntil = startedAt + 120; // åˆå›³ç›´å¾Œã®èª¤æ¤œçŸ¥å¯¾ç­–
      armed = true;

      statusEl.textContent = "GO!";
    }, delay);
  }

  startBtn.addEventListener("click", async () => {
    try {
      // é€£æ‰“å¯¾ç­–ï¼ˆæ¼”å‡º/è¨ˆæ¸¬ä¸­ã¯Startç„¡åŠ¹ï¼‰
      startBtn.disabled = true;
      stopBtn.disabled = false;

      statusEl.textContent = "Requesting microphone permission...";
      await initAudio();

      // iOSå¯¾ç­–ï¼šAudioContextãŒsuspendedãªã‚‰resume
      if (audioCtx.state === "suspended") await audioCtx.resume();

      // è¨ˆæ¸¬æº–å‚™
      listening = true;
      armed = false;

      // å¿µã®ãŸã‚åœæ­¢ç³»ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰é–‹å§‹
      stopAllTimers();

      // ç›£è¦–ãƒ«ãƒ¼ãƒ—é–‹å§‹
      rafId = requestAnimationFrame(loop);

      // ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹ï¼ˆè¡¨ç¤ºâ†’ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆâ†’ãƒ©ãƒ³ãƒ€ãƒ â†’GOï¼‰
      const myToken = ++seqToken; // ã“ã®é–‹å§‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ID
      await runStartSequence(myToken);

    } catch (e) {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      resetUI("Microphone error. Browser permission or unsupported device.");
      console.error(e);
    }
  });

  stopBtn.addEventListener("click", () => {
    hardStop("Stopped.");
  });

  resetBtn.addEventListener("click", () => {
    hardReset("Reset.");
  });

  // åˆæœŸè¡¨ç¤º
  resetUI("Ready.");
})();
</script>
</body>
</html>

